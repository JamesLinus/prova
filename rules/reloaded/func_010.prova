% Demonstrate a simple variant of stream fusion like functionality.
% The double map results in the state variable (sum) being threaded for each
%   element in the supplied list.
% This is equivalent to Scala code below but does not have recursion or list copying. 
%   def scalaLibrarySum(a : Array[Int]) = a.map(i => i * 3 + 7).filter(i => (i % 10) == 0).foldLeft(0)(_ + _)

:- eval(consult('rules/rules3/functional.prova')).

% This returns:
% SF1=[state,[[list,1,-1,3,11],50]]
:-solve(stream_fusion_1(SF1)).

a([I,S],[I,SMB]) :-
	IM=I*3+7,
	b([IM,S],[IMB,SMB]).

b([I,S],[I,SM]) :-
	0=I mod 10,
	!,
	SM=S+I.
b([I,S],[I,S]).

stream_fusion_1(X) :-
	derive(
		[[map([map(a)])],state([list(1,-1,3,11),0]),X]
	).
