% Demonstrate unfoldr-like functionality with embedded reactions.
% The process continues generating the output stream until
%     the condition cond is verified: the sum of the previous input with new data is 5.
% This outputs:
% 
% {s=1}
% {s=2}
% {s=3}
% SF3=[state,[[list,1,3,5],[]]]

:- eval(consult('rules/reloaded/functional.prova')).

:- solve(test_unfoldr_3(SF3)).

:- eval(client()).

client() :-
	switch_thread(),
	sendMsg(xid,async,0,data,{s:1}),
	sendMsg(xid,async,0,data,{s:2}),
	sendMsg(xid,async,0,data,{s:3}),
	sendMsg(xid,async,0,data,{s:4}).
	
switch_thread() :-
	sendMsgSync(XID,task,0,switch,[]),
	rcvMsg(XID,task,From,switch,[]).

accept([[],maybe(just([I]))],maybe(just([J,K]))) :-
	rcvMsg(xid,async,From,data,{s:J}),
	println([{s:J}]),
	K=I+J.

% This defines a Haskell Stream just like in the Coutts' or Gibbons papers.
% list(N) emits a new head (from the alphabet) while maybe holds the new data or Nothing for termination.
cond([N,maybe(just([J,N]))],[list(N),maybe(nothing())]) :-
	!.
cond([N,maybe(just([J,K]))],[list(K),maybe(just([J]))]).

% This could be formalized as (x is Cartesian product):
% Exists s.(s->1+Integer X s) x s
% Here maybe(just(0)) is the original seed state
% and cond(5) . accept is a composition pipeline.
% Note that our approach is general enough to cover Coutts' Skip easily as we can emit 0 or more new data.
% For example, list() denotes a Skip.
test_unfoldr_3(X) :-
	derive(
		[[map([map([accept,cond(5)])])],state([list([]),maybe(just([0]))]),X]
	).
